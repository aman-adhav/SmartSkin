<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">.lst-kix_i2bgj5pepswx-5>li:before{content:"\0025a0  "}.lst-kix_i2bgj5pepswx-6>li:before{content:"\0025cf  "}.lst-kix_i2bgj5pepswx-3>li:before{content:"\0025cf  "}.lst-kix_i2bgj5pepswx-4>li:before{content:"\0025cb  "}.lst-kix_i2bgj5pepswx-7>li:before{content:"\0025cb  "}.lst-kix_i2bgj5pepswx-8>li:before{content:"\0025a0  "}ol.lst-kix_dlk6ycbkzbeg-6.start{counter-reset:lst-ctn-kix_dlk6ycbkzbeg-6 0}ul.lst-kix_i2bgj5pepswx-7{list-style-type:none}ul.lst-kix_i2bgj5pepswx-8{list-style-type:none}.lst-kix_kuwf95lr5t4r-0>li:before{content:"  "}ol.lst-kix_dlk6ycbkzbeg-3.start{counter-reset:lst-ctn-kix_dlk6ycbkzbeg-3 0}ul.lst-kix_i2bgj5pepswx-3{list-style-type:none}ul.lst-kix_i2bgj5pepswx-4{list-style-type:none}ul.lst-kix_i2bgj5pepswx-5{list-style-type:none}ul.lst-kix_i2bgj5pepswx-6{list-style-type:none}ul.lst-kix_i2bgj5pepswx-0{list-style-type:none}ul.lst-kix_i2bgj5pepswx-1{list-style-type:none}ul.lst-kix_i2bgj5pepswx-2{list-style-type:none}.lst-kix_dlk6ycbkzbeg-7>li{counter-increment:lst-ctn-kix_dlk6ycbkzbeg-7}ul.lst-kix_uvj7aj3tevjg-0{list-style-type:none}ul.lst-kix_uvj7aj3tevjg-2{list-style-type:none}ul.lst-kix_uvj7aj3tevjg-1{list-style-type:none}ul.lst-kix_uvj7aj3tevjg-8{list-style-type:none}ul.lst-kix_uvj7aj3tevjg-7{list-style-type:none}ul.lst-kix_uvj7aj3tevjg-4{list-style-type:none}ul.lst-kix_uvj7aj3tevjg-3{list-style-type:none}ul.lst-kix_uvj7aj3tevjg-6{list-style-type:none}ul.lst-kix_uvj7aj3tevjg-5{list-style-type:none}.lst-kix_kuwf95lr5t4r-5>li:before{content:"\0025a0  "}.lst-kix_kuwf95lr5t4r-6>li:before{content:"\0025cf  "}.lst-kix_kuwf95lr5t4r-4>li:before{content:"\0025cb  "}.lst-kix_kuwf95lr5t4r-8>li:before{content:"\0025a0  "}.lst-kix_kuwf95lr5t4r-1>li:before{content:"\0025cb  "}.lst-kix_kuwf95lr5t4r-2>li:before{content:"\0025a0  "}.lst-kix_dlk6ycbkzbeg-5>li{counter-increment:lst-ctn-kix_dlk6ycbkzbeg-5}.lst-kix_dlk6ycbkzbeg-8>li{counter-increment:lst-ctn-kix_dlk6ycbkzbeg-8}.lst-kix_kuwf95lr5t4r-3>li:before{content:"\0025cf  "}.lst-kix_i2bgj5pepswx-0>li:before{content:"  "}.lst-kix_i2bgj5pepswx-1>li:before{content:"\0025cb  "}.lst-kix_i2bgj5pepswx-2>li:before{content:"\0025a0  "}.lst-kix_kuwf95lr5t4r-7>li:before{content:"\0025cb  "}ol.lst-kix_dlk6ycbkzbeg-4.start{counter-reset:lst-ctn-kix_dlk6ycbkzbeg-4 0}.lst-kix_dlk6ycbkzbeg-3>li{counter-increment:lst-ctn-kix_dlk6ycbkzbeg-3}.lst-kix_uvj7aj3tevjg-1>li:before{content:"\0025cb  "}ol.lst-kix_dlk6ycbkzbeg-3{list-style-type:none}ol.lst-kix_dlk6ycbkzbeg-4{list-style-type:none}.lst-kix_1wvwf3r2v5e8-0>li:before{content:"-  "}.lst-kix_uvj7aj3tevjg-0>li:before{content:"  "}ol.lst-kix_dlk6ycbkzbeg-5{list-style-type:none}ol.lst-kix_dlk6ycbkzbeg-6{list-style-type:none}ol.lst-kix_dlk6ycbkzbeg-0{list-style-type:none}ol.lst-kix_dlk6ycbkzbeg-1{list-style-type:none}ol.lst-kix_dlk6ycbkzbeg-2{list-style-type:none}ol.lst-kix_dlk6ycbkzbeg-2.start{counter-reset:lst-ctn-kix_dlk6ycbkzbeg-2 0}ol.lst-kix_dlk6ycbkzbeg-7{list-style-type:none}ol.lst-kix_dlk6ycbkzbeg-8{list-style-type:none}.lst-kix_dlk6ycbkzbeg-2>li{counter-increment:lst-ctn-kix_dlk6ycbkzbeg-2}ul.lst-kix_kuwf95lr5t4r-8{list-style-type:none}ol.lst-kix_dlk6ycbkzbeg-5.start{counter-reset:lst-ctn-kix_dlk6ycbkzbeg-5 0}ul.lst-kix_1wvwf3r2v5e8-0{list-style-type:none}ul.lst-kix_kuwf95lr5t4r-7{list-style-type:none}ul.lst-kix_kuwf95lr5t4r-6{list-style-type:none}ul.lst-kix_1wvwf3r2v5e8-2{list-style-type:none}ul.lst-kix_kuwf95lr5t4r-5{list-style-type:none}ul.lst-kix_1wvwf3r2v5e8-1{list-style-type:none}ul.lst-kix_kuwf95lr5t4r-4{list-style-type:none}ul.lst-kix_kuwf95lr5t4r-3{list-style-type:none}ul.lst-kix_kuwf95lr5t4r-2{list-style-type:none}ul.lst-kix_kuwf95lr5t4r-1{list-style-type:none}ul.lst-kix_kuwf95lr5t4r-0{list-style-type:none}ul.lst-kix_1wvwf3r2v5e8-8{list-style-type:none}.lst-kix_1wvwf3r2v5e8-7>li:before{content:"-  "}ul.lst-kix_1wvwf3r2v5e8-7{list-style-type:none}.lst-kix_1wvwf3r2v5e8-8>li:before{content:"-  "}.lst-kix_uvj7aj3tevjg-8>li:before{content:"\0025a0  "}.lst-kix_uvj7aj3tevjg-7>li:before{content:"\0025cb  "}ul.lst-kix_1wvwf3r2v5e8-4{list-style-type:none}ul.lst-kix_1wvwf3r2v5e8-3{list-style-type:none}.lst-kix_1wvwf3r2v5e8-6>li:before{content:"-  "}ul.lst-kix_1wvwf3r2v5e8-6{list-style-type:none}ul.lst-kix_1wvwf3r2v5e8-5{list-style-type:none}.lst-kix_uvj7aj3tevjg-5>li:before{content:"\0025a0  "}.lst-kix_1wvwf3r2v5e8-3>li:before{content:"-  "}.lst-kix_1wvwf3r2v5e8-4>li:before{content:"-  "}.lst-kix_uvj7aj3tevjg-4>li:before{content:"\0025cb  "}.lst-kix_uvj7aj3tevjg-6>li:before{content:"\0025cf  "}.lst-kix_dlk6ycbkzbeg-1>li{counter-increment:lst-ctn-kix_dlk6ycbkzbeg-1}.lst-kix_1wvwf3r2v5e8-1>li:before{content:"-  "}.lst-kix_1wvwf3r2v5e8-5>li:before{content:"-  "}.lst-kix_uvj7aj3tevjg-2>li:before{content:"\0025a0  "}.lst-kix_uvj7aj3tevjg-3>li:before{content:"\0025cf  "}.lst-kix_1wvwf3r2v5e8-2>li:before{content:"-  "}.lst-kix_dlk6ycbkzbeg-4>li{counter-increment:lst-ctn-kix_dlk6ycbkzbeg-4}.lst-kix_dlk6ycbkzbeg-0>li:before{content:"" counter(lst-ctn-kix_dlk6ycbkzbeg-0,decimal) ". "}.lst-kix_dlk6ycbkzbeg-6>li{counter-increment:lst-ctn-kix_dlk6ycbkzbeg-6}.lst-kix_dlk6ycbkzbeg-1>li:before{content:"" counter(lst-ctn-kix_dlk6ycbkzbeg-1,lower-latin) ". "}.lst-kix_dlk6ycbkzbeg-0>li{counter-increment:lst-ctn-kix_dlk6ycbkzbeg-0}.lst-kix_dlk6ycbkzbeg-2>li:before{content:"" counter(lst-ctn-kix_dlk6ycbkzbeg-2,lower-roman) ". "}ol.lst-kix_dlk6ycbkzbeg-8.start{counter-reset:lst-ctn-kix_dlk6ycbkzbeg-8 0}.lst-kix_dlk6ycbkzbeg-3>li:before{content:"" counter(lst-ctn-kix_dlk6ycbkzbeg-3,decimal) ". "}.lst-kix_dlk6ycbkzbeg-5>li:before{content:"" counter(lst-ctn-kix_dlk6ycbkzbeg-5,lower-roman) ". "}.lst-kix_dlk6ycbkzbeg-4>li:before{content:"" counter(lst-ctn-kix_dlk6ycbkzbeg-4,lower-latin) ". "}.lst-kix_dlk6ycbkzbeg-8>li:before{content:"" counter(lst-ctn-kix_dlk6ycbkzbeg-8,lower-roman) ". "}.lst-kix_dlk6ycbkzbeg-7>li:before{content:"" counter(lst-ctn-kix_dlk6ycbkzbeg-7,lower-latin) ". "}ol.lst-kix_dlk6ycbkzbeg-0.start{counter-reset:lst-ctn-kix_dlk6ycbkzbeg-0 0}.lst-kix_dlk6ycbkzbeg-6>li:before{content:"" counter(lst-ctn-kix_dlk6ycbkzbeg-6,decimal) ". "}ol.lst-kix_dlk6ycbkzbeg-7.start{counter-reset:lst-ctn-kix_dlk6ycbkzbeg-7 0}ol.lst-kix_dlk6ycbkzbeg-1.start{counter-reset:lst-ctn-kix_dlk6ycbkzbeg-1 0}ol{margin:0;padding:0}table td,table th{padding:0}.c22{margin-left:36pt;padding-top:3pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c9{margin-left:18pt;padding-top:3pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c16{padding-top:10pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c29{padding-top:4pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c7{padding-top:0pt;padding-bottom:0pt;line-height:2.0;orphans:2;widows:2;text-align:center}.c19{color:#000000;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c13{color:#000000;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c28{padding-top:10pt;padding-bottom:4pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c2{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c26{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:right}.c3{padding-top:0pt;padding-bottom:0pt;line-height:2.0;orphans:2;widows:2;text-align:left}.c18{color:#000000;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c27{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c23{color:#434343;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:normal}.c17{padding-top:18pt;padding-bottom:6pt;line-height:2.0;page-break-after:avoid;text-align:left}.c12{padding-top:20pt;padding-bottom:6pt;line-height:2.0;page-break-after:avoid;text-align:left}.c30{padding-top:20pt;padding-bottom:6pt;line-height:2.0;page-break-after:avoid;text-align:center}.c24{padding-top:16pt;padding-bottom:4pt;line-height:2.0;page-break-after:avoid;text-align:left}.c31{padding-top:20pt;padding-bottom:6pt;line-height:1.0;page-break-after:avoid;text-align:left}.c21{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c14{color:inherit;text-decoration:inherit}.c25{padding:0;margin:0}.c10{margin-left:36pt;padding-left:0pt}.c8{background-color:#ffffff;color:#222222}.c11{margin-left:-49.5pt}.c6{font-weight:400}.c20{margin-left:-58.5pt}.c15{vertical-align:sub}.c4{height:11pt}.c0{font-weight:700}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c21"><div><p class="c26"><span>Adhav </span></p></div><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c7"><span class="c2 c0">A safer alternative to Smart Skin : The design and fabrication of Piezoresistive Trackpad to simulate &ldquo;touch&rdquo; for bionic limbs and robots </span></p><p class="c7 c4"><span class="c2 c0"></span></p><p class="c7 c4"><span class="c2 c0"></span></p><p class="c7 c4"><span class="c2 c0"></span></p><p class="c7 c4"><span class="c2 c0"></span></p><p class="c4 c7"><span class="c2 c0"></span></p><p class="c7"><span class="c2 c0">A Science Fair Project Presented to</span></p><p class="c7 c4"><span class="c2 c0"></span></p><p class="c7"><span class="c2 c0">Bay Area Science and Engineering Fair 2017</span></p><p class="c7"><span class="c2 c0">By:</span></p><p class="c7 c4"><span class="c2 c0"></span></p><p class="c7"><span class="c0 c2">Aman Adhav</span></p><p class="c7"><span class="c2 c0">White Oaks secondary School</span></p><p class="c7 c4"><span class="c2 c0"></span></p><p class="c7"><span class="c2 c0">Oakville, Ontario, Canada</span></p><p class="c7"><span class="c2 c0">&nbsp;March 31st 2017</span></p><p class="c7 c4"><span class="c2 c0"></span></p><p class="c3"><span class="c2 c6">Table of Contents : </span></p><p class="c29"><span class="c0"><a class="c14" href="#h.kcbmtv7yj4cz">Abstract</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.kcbmtv7yj4cz">3</a></span></p><p class="c16"><span class="c0"><a class="c14" href="#h.pff8krqzrakn">Acknowledgements :</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.pff8krqzrakn">4</a></span></p><p class="c16"><span class="c0"><a class="c14" href="#h.fcsnkn2dcsnl">Introduction</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.fcsnkn2dcsnl">6</a></span></p><p class="c9"><span><a class="c14" href="#h.d5asg9wm8qm3">Motivation : Alternative to the conventional rigid trackpad</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c14" href="#h.d5asg9wm8qm3">7</a></span></p><p class="c9"><span><a class="c14" href="#h.kfccgiq4z3ls">Goals and Objectives :</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c14" href="#h.kfccgiq4z3ls">10</a></span></p><p class="c9"><span><a class="c14" href="#h.yluz5q671yed">Overview</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c14" href="#h.yluz5q671yed">10</a></span></p><p class="c16"><span class="c0"><a class="c14" href="#h.nptmeuz615t5">Hypothesis</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.nptmeuz615t5">11</a></span></p><p class="c16"><span class="c0"><a class="c14" href="#h.4soinpeyx4ga">Software Development</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.4soinpeyx4ga">13</a></span></p><p class="c16"><span class="c0"><a class="c14" href="#h.6yd06evs0tky">Location sensing using Trilateration</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.6yd06evs0tky">15</a></span></p><p class="c9"><span><a class="c14" href="#h.ot8on441259m">Mathematics behind trilateration</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c14" href="#h.ot8on441259m">17</a></span></p><p class="c9"><span><a class="c14" href="#h.e2mslpy8f7kx">Instrumentation</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c14" href="#h.e2mslpy8f7kx">20</a></span></p><p class="c16"><span class="c0"><a class="c14" href="#h.stdim9a84lxg">Experiment &amp; Process</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.stdim9a84lxg">23</a></span></p><p class="c9"><span><a class="c14" href="#h.ggb3tt7y1if">Plot 1 : Intersection of circles</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c14" href="#h.ggb3tt7y1if">23</a></span></p><p class="c9"><span><a class="c14" href="#h.4ilnbiy3wosr">Plot 2 : X, Y coordinate location</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c14" href="#h.4ilnbiy3wosr">24</a></span></p><p class="c9"><span><a class="c14" href="#h.5zw4gcw1tg1y">Graph analysis</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c14" href="#h.5zw4gcw1tg1y">24</a></span></p><p class="c22"><span><a class="c14" href="#h.pky9txs0njjs">Accuracy Calculation</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c14" href="#h.pky9txs0njjs">25</a></span></p><p class="c22"><span><a class="c14" href="#h.qh1hbrg1kanv">Disconformity calculations</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c14" href="#h.qh1hbrg1kanv">26</a></span></p><p class="c16"><span class="c0"><a class="c14" href="#h.wsg23tmwvv1w">Conclusion</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.wsg23tmwvv1w">27</a></span></p><p class="c16"><span class="c0"><a class="c14" href="#h.2fwkvofk8iin">Future Direction</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.2fwkvofk8iin">28</a></span></p><p class="c16"><span class="c0"><a class="c14" href="#h.xr3v4os4bxy5">Appendix A : Arduino four corner sensing code</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.xr3v4os4bxy5">29</a></span></p><p class="c16"><span class="c0"><a class="c14" href="#h.fqsf4njyitfu">Appendix B : Arduino X, Y coordinate determination program</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.fqsf4njyitfu">30</a></span></p><p class="c16"><span class="c0"><a class="c14" href="#h.xci3z3ikphjx">Appendix C : Processing circular intersection visualization</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.xci3z3ikphjx">31</a></span></p><p class="c16"><span class="c0"><a class="c14" href="#h.jvcp4wlz8hvj">Appendix D : Processing trilateration X,Y point visualization</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.jvcp4wlz8hvj">32</a></span></p><p class="c28"><span class="c0"><a class="c14" href="#h.rah8j0ua6t29">References</a></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0"><a class="c14" href="#h.rah8j0ua6t29">34</a></span></p><p class="c4 c27"><span class="c2 c0"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><h1 class="c30" id="h.kcbmtv7yj4cz"><span class="c13 c6">Abstract</span></h1><p class="c7 c4"><span class="c2 c6"></span></p><p class="c7 c4"><span class="c2 c6"></span></p><p class="c7"><span class="c2 c6">The safer alternative to Smart skin : The design and fabrication of piezoresistive trackpad to simulate &ldquo;touch&rdquo; for bionic limbs and robot parts</span></p><p class="c7"><span class="c2 c6">&nbsp;</span></p><p class="c3"><span class="c2 c6">Aman Adhav &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c3"><span class="c2 c6">Bay Area Science Fair, 2017</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span>Currently, Smart skin technologies are primarily being used as sensors and to control devices.</span><span class="c2 c6">&nbsp;However, using Smart skin technology is problematic: the metals and chemicals used in Smart skins can enter the bloodstream, potentially leading to major health problems such as metal poisoning, Alzheimer&#39;s disease, and cancer. This project presents the design and fabrication of a piezoresistive flexible surface for quantifying &ldquo;touch&rdquo; on surfaces such as the human skin. The piezoresistive fabric is a transducer that senses touch and pressure. Results show, the signals from the surface can be converted into Euclidean coordinates using a multilateration algorithm. As an illustration of the concept, were initialized and programmed to control radio frequency devices when touched.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><h1 class="c12" id="h.pff8krqzrakn"><span class="c13 c6">Acknowledgements : </span></h1><p class="c3"><span class="c2 c6">Mike McBrien</span></p><p class="c3"><span class="c2 c6">Ajita Adhav</span></p><p class="c3"><span class="c2 c6">Dr. Adrian Freed professor, Center of Music and Audio Technologies (CNMAT) University of Berkley California</span></p><p class="c3"><span class="c2 c6">White Oaks Secondary School, my family and friends</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c4 c28"><span class="c2 c6"></span></p><h1 class="c12" id="h.fcsnkn2dcsnl"><span class="c6 c13">Introduction</span></h1><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">The purpose of this project is to describe the development, fabrication and validation of a novel piezoresistive fabric flexible surface for the purpose of detecting and quantifying touch. This was accomplished with a piezoresistive fabric that conforms to curved surfaces. Recognizing &ldquo;touch&rdquo; on curved surfaces can cause problems with signals as the fabric can transduce pressure.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">Currently, Smartskin technologies are primarily being used as sensors and to control devices. However, using Smartskin technology is problematic: the metals and chemicals used in Smartskins can enter the bloodstream, potentially leading to major health problems such as metal poisoning, Alzheimer&#39;s disease, and cancer (Edwards, 2014). This project uses Piezoelectric fabric as a transducer to sense touch and pressure and convert those signals into locations on a screen. It presents location sensing technologies that can be used to control radio frequency &amp; bluetooth devices.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><h2 class="c17" id="h.d5asg9wm8qm3"><span class="c18 c6">Motivation : Alternative to the conventional rigid trackpad</span></h2><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">The conventional 4-wire resistive touchscreens consist of two top transparent glass or acrylic panels and a bottom transparent insulating panel. Both top panels are coated with electrically conductive layers. These layers have uniform resistance made from indium tin oxide (ITO). The panels are separated by invisible non-conducting spacers. </span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 336.00px; height: 270.00px;"><img alt="" src="images/image7.png" style="width: 336.00px; height: 270.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span>The top layer panel is flexible and the bottom layer panel is rigid. Pressing the flexible top sheet creates an electrical contact between the resistive layers, essentially closing a switch in the circuit. The four electrical wires are connected to conductive bars. </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 353.00px; height: 162.00px;"><img alt="" src="images/image21.png" style="width: 353.00px; height: 162.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">As illustrated in the diagram, touch is calculated by finding the resistance on the two plates. This system has been proven very effective however, a solution can be found by implementing a simpler method (Cheng, Tsao,Lai, &amp; Yang, 2011; Lemerle et al., 2008).</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 426.00px; height: 376.50px;"><img alt="" src="images/image4.png" style="width: 426.00px; height: 376.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c2 c6">&nbsp;</span></p><p class="c3"><span class="c0">Figure (A) : Graphical representation of the connections with Piezoresistive fabric</span><span class="c2 c6">&nbsp; &nbsp;</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 346.50px; height: 346.50px;"><img alt="" src="images/image30.png" style="width: 346.50px; height: 346.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c0">Figure (B) : Representation of location finding using Piezoresistive fabric</span></p><p class="c3"><span class="c2 c6">The following figures illustrate how the values are being interpreted in the arduino. The locations that are calculated in this proposal are using a trilateration algorithm. Trilateration is a geolocation concept that uses radii of circles and their areas in order to determine coordinates. By using the ADC (Analog to digital converted) values, locations can be determined by calculating the intersection of circles as shown in Figure (B). </span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">In conclusion, the project uses a simpler method to calculate the location coordinates than conventional resistive trackpads (Aldien, Welcome, Rakheja, Dong, &amp; Boileau, 2004; Hoozemans &amp; van Die&euml;n, 2005; Welcome, Rakheja, Dong, Wu, &amp; Schopper, 2004)</span></p><p class="c3"><span class="c2 c6">. </span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">There is a significant difference in costs for the production of a resistive touchpad, which can be reduced using the algorithms and method implemented in this project. The piezoresistive fabrics are cheap to manufacture and safe to use. This cost efficient method is safer and far superior than any Smart skin.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><h2 class="c17" id="h.kfccgiq4z3ls"><span class="c18 c6">Goals and Objectives : </span></h2><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">The ultimate goal of this project is to create a new technology that can potentially revolutionize the wearables and bionics industries. Smart wearables can help the disabled control radio frequency devices by using the fabric as a location tracking sensor. This work encompasses the following objectives : </span></p><p class="c3 c4"><span class="c2 c6"></span></p><ul class="c25 lst-kix_1wvwf3r2v5e8-0 start"><li class="c3 c10"><span class="c2 c6">Design a circuit that receives values that can quantify hand forces on any surfaces.</span></li><li class="c3 c10"><span class="c2 c6">Create an algorithm that can convert analog values to Euclidean coordinates.</span></li><li class="c3 c10"><span class="c2 c6">Control radio frequency operated devices with touch pad.</span></li></ul><p class="c3 c4"><span class="c2 c6"></span></p><h2 class="c17" id="h.yluz5q671yed"><span>Overview </span></h2><p class="c3"><span class="c2 c6">Smart skin technology as a whole is very invasive as it requires to be imprinted on the skin. Unlike the piezoresistive fabrics, metals inside Smart skins can be lethal. A solution for this problem could be a non invasive transducer, that can quantify hand forces into coordinates. An attempt by University of British Colombia&rsquo;s professor Dr. John Madden, created a transparent pressure matrix that can be used to sense touch at different locations. However the complexity of the project made it unfeasible option as the pressure matrix are only 3 cm X 3 cm (Madden, 2014). The project was also very expensive and required complex compounds that made the project difficult to scale. </span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">Pressure matrix or trackpads have always been used for location tracking. They are better than Smart skins yet they cannot conform due to their structure. Piezoresistive fabrics have conductive properties that allow them to be stretched and conformed. They also make great pressure sensors as they consist of silicon and carbon compounds. With these properties in play, it is possible to achieve location tracking on a large scale using these fabrics (Antony &amp; Keir, 2010; Brookham, Wong, &amp; Dickerson, 2010; Sporrong, Palmerud, &amp; Herberts, 1996).</span></p><p class="c3"><span class="c2 c6">.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">In this project, the experiments that will be conducted study the properties the properties of piezoresistive fabrics and their effectiveness in order to achieve location tracking.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><h1 class="c12" id="h.nptmeuz615t5"><span class="c13 c6">Hypothesis </span></h1><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">If the pressure of the hand force on the fabric increases, then the analog values increase because adding pressure causes there to be more resistance added, causing deformations and effecting the output analog values greatly.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">In order to interpret values from the piezoresistive fabric, the analog values must be converted to digital values. The analog values range from 0V to 5V. These values need to be mapped from 0 to 1023 in order to achieve the theoretical range (Burstr&ouml;m &amp; Lundstr&ouml;m, 2011). </span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">A test must be conducted with the fabric in order to linearize the values that are being interpreted. To do so, Voltages are calculated at diagonally, from Vcc to GND. </span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 435.55px; height: 495.50px;"><img alt="" src="images/image2.png" style="width: 435.55px; height: 495.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c2 c0">Figure 1: Main window of data logging program used (RS232 Data Logger&trade;) </span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><h1 class="c12" id="h.4soinpeyx4ga"><span class="c13 c6">Software Development</span></h1><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">A program called Data Logger was used to find analog voltages using an Arduino UNO. The data received from the microcontroller. Once captured by the data logging software, the data must be calibrated by choosing every 10th value at a 5 ms intervals. This is accomplished with the use of the spreadsheet program Microsoft&trade; Excel.</span></p><p class="c3"><span class="c2 c6">To illustrate this example the following diagram is drawn. Voltage values are collected by connecting analog read sensels to each of the points on the grid as shown in the figure below. These values are then added to excel in the spreadsheet and graphed accordingly.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image9.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c0">Figure 2 : Diagram illustrates the locations where data was collected</span><span class="c2 c6">.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 217.33px;"><img alt="" src="images/image29.png" style="width: 624.00px; height: 217.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c2 c0">Table 1 : Example of the steps for augmenting the data into datasets, representing the raw data and locations</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 600.00px; height: 371.00px;"><img alt="" src="images/image14.png" style="width: 600.00px; height: 371.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title="Chart"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c0">Conclusion : </span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">As the distance from Vcc increases, the resistance drastically changes. As seen in the graph, the points correlate very closely with a logarithmic graph (Bao &amp; Silverstein, 2005; Duque, Masset, &amp; Malchaire, 1995).</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">The devised formula for the sensel pins is (Kuijt-Evers et al., 2007) : </span></p><p class="c3"><span class="c2 c6">:</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 336.00px; height: 34.00px;"><img alt="" src="images/image13.png" style="width: 336.00px; height: 34.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">Where a and b are constants that can help derive an equation for the sensor values.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">This can be an effective solution to deriving for calculating the Euclidean coordinates, however due to constant changes in pressure, temperature and stretch, the equation is not universal and would require a calibration algorithm.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><h1 class="c12" id="h.6yd06evs0tky"><span>Location sensing using Trilateration </span></h1><p class="c3"><span class="c2 c6">The method implemented to find Euclidean coordinates is called trilateration. Trilateration as a concept uses radii and centroids of the circle to form an intersection. This intersection has an area that can be defined by a coordinates. Trilateration is commonly used in Geography instead of Triangulation; which requires angles and distances to calculate the coordinates (Lau, 2011).</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 283.63px; height: 282.50px;"><img alt="" src="images/image25.png" style="width: 283.63px; height: 282.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c2 c0">Figure 3 : Diagram illustrates coordinate location finding using trilateration using intersection points (McAtamney &amp; Nigel Corlett, 1993).</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">In the project, trilateration as a concept was used with four circles in order to create 2 intersection areas and points. </span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 247.85px; height: 249.50px;"><img alt="" src="images/image18.png" style="width: 247.85px; height: 249.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7 c4"><span class="c2 c6"></span></p><p class="c7"><span class="c0">Figure 4 : Coordinates representing the intersection of two regions</span><span class="c2 c6">&nbsp;</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">The figure show how using trilateration the intersection of the of the 4 circles is found. In order to determine the exact contact specific locations of the coordinates, the project uses a comparison algorithm that find the sensel pin with the smallest raw value and compares the result to the two intersections.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><h2 class="c17" id="h.ot8on441259m"><span class="c18 c6">Mathematics behind trilateration </span></h2><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">To compute the trilateration, 3 circles with known radii and coordinate location of their centres is required. To define these parameters, the radii will be the digitally converted values from the Analog To Digital converter. In the program, the parameters for the length and height of the screen are set for (600,600). Respectively the coordinates of each circle would be : (600,0), (600,600), (0,0), (0,600).</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 410.67px;"><img alt="" src="images/image22.png" style="width: 624.00px; height: 410.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c2 c0">Graph 2 : Geometric representation of Euclidean coordinate location using trilateration (created in Desmos)</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">Graph showing layout of the circles and the points and the intersection points. In order to determine the equations for the coordinates (Takala et al., 2010) :</span></p><p class="c3 c4"><span class="c2 c6"></span></p><ol class="c25 lst-kix_dlk6ycbkzbeg-0 start" start="1"><li class="c3 c10"><span class="c2 c6">Finding the intersection of three of the four circles by finding the radii and the location of the center points.</span></li><li class="c3 c10"><span class="c2 c6">The three unknown circles and their points being x,y,z. </span></li><li class="c3 c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 229.00px; height: 86.00px;"><img alt="" src="images/image1.png" style="width: 229.00px; height: 86.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></li><li class="c3 c10"><span>Using the following equations, where r</span><span class="c15">1 </span><span>r</span><span class="c15">2 </span><span>r</span><span class="c15">3</span><span class="c2 c6">&nbsp;are the radii of the respected circles. &lsquo;d&rsquo; is the location of the second circle and (i,j) are the coordinates of the third circle.</span></li><li class="c3 c10"><span class="c2 c6">A system of equations can be formulated using these equations in order to create a universal equation for the x and y values.</span></li><li class="c3 c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 246.00px; height: 232.00px;"><img alt="" src="images/image28.png" style="width: 246.00px; height: 232.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></li><li class="c3 c10"><span class="c2 c6">As shown in the system of equations, y and z are eliminated leaving a very simple solution for x.</span></li><li class="c3 c10"><span class="c2 c6">After substituting x back into one of the equation, a solution for y can be achieved.</span></li><li class="c3 c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 465.00px; height: 56.00px;"><img alt="" src="images/image12.png" style="width: 465.00px; height: 56.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></li><li class="c3 c10"><span class="c2 c6">Steps 1-9 are repeated in order to calculate the intersection for the 4th circle. The 3rd circle needs to be replaced in the steps.</span></li></ol><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">In the process shown above, equations for the x and y coordinates can be calculated. The trilateration algorithm in this project uses the same method in order to find the x and y coordinates (Webster, 1999).</span></p><p class="c3 c4"><span class="c2 c6"></span></p><h2 class="c17" id="h.e2mslpy8f7kx"><span class="c18 c6">Instrumentation </span></h2><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">This section describes the equipment used to collect data and analyze the data obtained.</span></p><p class="c3"><span class="c2 c6">Arduino Uno R3 : </span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 399.50px; height: 250.00px;"><img alt="" src="images/image5.png" style="width: 399.50px; height: 250.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c2 c0">Figure 5 : Representation of the Arduino Uno R3 pinout and board layout (Adafruit, 2011)</span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3"><span class="c2 c6">The Arduino uno is a microcontroller board with 14v digital Input/Output pins, 6 analog inputs, 16MHz quartz crystal, a USB connection a power input and a rest button (Adafruit, 2011).</span></p><p class="c3"><span>&nbsp;Analog input A0, digital pins 2 - 5 and GND were the only pins used in this project. The analog input pin was the sensor pin that established contact with the fabric when touched. The digital pins 2-5 were connected to corners of the fabric (Gautschi, 2006). These pins supplied voltage to the corners of the fabric. Pull up resistors were used </span><span class="c8">to ensure that inputs to the arduino settle at expected logic levels if external devices are disconnected or there is high-impedance (Spielholz et al., 2008).</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">Pull-up resistors attached between the piezoresistive fabric and the Arduino were used to establish a controlled current flow from the Arduino to the fabric and act as a voltage divider which permitted the sensitivity of the fabric to be changed externally. 780&Omega; resistors were used based on the fact that they act as pull-up resistor (Eltaib &amp; Hewit, 2003).</span></p><p class="c3"><span class="c2 c6">. </span></p><p class="c3"><span class="c2 c0">Circuit diagram and layout :</span></p><p class="c3"><span>&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 479.00px; height: 299.00px;"><img alt="" src="images/image3.png" style="width: 479.00px; height: 299.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c0">Figure 5 : Schematic of the pull-up circuitry used for connecting the sensor to the Arduino&trade;</span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 447.00px; height: 321.00px;"><img alt="" src="images/image27.png" style="width: 447.00px; height: 321.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c2 c0">Figure 6 : Flowchart of the electrical circuit </span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3"><span>The pull-up circuitry is connected between the sensor and microcontroller. Once the signal has passed the pull-up circuit, the microcontroller (V</span><span class="c15">IN</span><span>) reads and stores the data through pin A0, which can be modelled by the following relationship, where the value (V</span><span class="c15">RN </span><span class="c2 c6">) of is the voltage across the pull-up resistor (Min-Hang Bao, 2000):</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c0">Equation : </span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 177.00px; height: 60.00px;"><img alt="" src="images/image16.png" style="width: 177.00px; height: 60.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><h1 class="c12" id="h.stdim9a84lxg"><span class="c13 c6">Experiment &amp; Process </span></h1><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">In order for location tracking to occur, at each end of the piezoelectric fabric a 5V (high) voltage needs to be applied. Location tracking occurs when 3 of the 4 sensels are high while the 4th one is low. However the sensels alternate and switch roles every 1 ms. An example would be [Sensel 1 (low), sensel 2,3,4 (high)], [Sensel 2 (low), sensel 1,3,4 (high)]. What is printed out in the arduino serial monitor is a series of analogread values between 0 - 1023. If values such as 1023 are outputted by the A0 pin, then it is safe to assume the pin is touching one of the 4 corners. This raw data is then further refined by choosing every 10th term at a 5 ms interval. </span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">In order to calculate locations using this data, the serial port of the arduino is synced with a software called Processing 3.0, it uses java 8.0 however has many inbuilt functions that can help create graphs and animation. In Processing the raw data values are scaled to fit inside a (600,600) area by using the map function. Once converted the data is then plotted.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><h2 class="c17" id="h.ggb3tt7y1if"><span class="c18 c6">Plot 1 : Intersection of circles</span></h2><p class="c3"><span class="c2 c6">This particular plot is effectively used to visualize trilateration and intersection of the circles. In this plot, in order to find the values a special trilateration function is written. &nbsp;The data from the each sensel is used as the radius for a circle. This function is used to calculate the coordinates of two points based on alternating between sensel 3 and 4. The coordinates are found by calculating finding the sensel which has the smallest value (from raw data indicating the radius). </span></p><p class="c3 c4"><span class="c2 c6"></span></p><h2 class="c17" id="h.4ilnbiy3wosr"><span class="c18 c6">Plot 2 : X, Y coordinate location </span></h2><p class="c3"><span class="c2 c6">In order to generate graph of the X, Y coordinate, the values computed from the trilateration algorithm are then converted to data points that needs to be graphed.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><h2 class="c17" id="h.5zw4gcw1tg1y"><span class="c18 c6">Graph analysis </span></h2><p class="c3"><span class="c2 c6">In order to determine the effectiveness of the piezoresistive fabric, disconformities need to be taken into consideration and how their changes affect the coordinate system. To calculate the disconformities, the piezoresistive fabric is mounted on curved surfaces with increasing heights.</span></p><p class="c3"><span class="c2 c6">To compute the accuracy of the data, the sensel pin A0 is secured to multiple points on the piezoresistive fabric. This will help determine the accuracy and effectiveness of the piezoresistive fabric.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><h3 class="c24" id="h.pky9txs0njjs"><span class="c23 c6">Accuracy Calculation </span></h3><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">The accuracy of data points can be computed and found out using the following.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 600.00px; height: 371.00px;"><img alt="" src="images/image20.png" style="width: 600.00px; height: 371.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title="Chart"></span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">Graph 3 illustrates the percentage errors for a sample of 9 points on the piezoresistive sensor. The quantified percentage error is the average of all the 9 errors. In data logger, every 10th value was used to find the coordinates at a 5 ms interval. In total there is a 7.48% error.</span></p><p class="c3"><span class="c2 c6">Refer to Table 4 in the appendix for data points and values. </span></p><p class="c3 c4"><span class="c2 c6"></span></p><h3 class="c24" id="h.qh1hbrg1kanv"><span class="c6 c23">Disconformity calculations </span></h3><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">In order to determine the effectiveness of the piezoresistive fabric, disconformities need to be taken into consideration and how their changes affect the coordinate system. To calculate the disconformities, the piezoresistive fabric is mounted on curved surfaces with increasing heights.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 400.91px; height: 218.50px;"><img alt="" src="images/image17.png" style="width: 400.91px; height: 218.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c0">Figure 6 : Illustrates the change in height of a curved surface from 1 cm - 10 cm</span><span class="c2 c6">&nbsp;</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">To compute the accuracy of the data, the sensel pin A0 is secured to multiple points on the piezoresistive fabric. On average, increase in the bend per cm, increases the percentage error of</span></p><p class="c3"><span class="c2 c6">the calculations by 2.46% for X values and 3.94% for Y values.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 498.50px; height: 307.74px;"><img alt="" src="images/image15.png" style="width: 498.50px; height: 307.74px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title="Chart"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 508.50px; height: 314.02px;"><img alt="" src="images/image19.png" style="width: 508.50px; height: 314.02px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title="Chart"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><h1 class="c12" id="h.wsg23tmwvv1w"><span class="c13 c6">Conclusion</span></h1><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3"><span class="c2 c6">As it stands now, using piezoresistive fabrics is definitely a safer alternative to Smart skins that have metals and chemicals which can be lethal to the human body. As proven in the project, piezoresistive fabrics are used as transducers to quantify Euclidean coordinates using trilateration. The applications of location sensing are vast: From virtual keyboards to radio frequency device control, this project has proven piezoresistive fabrics are a revolutionary the wearable technology.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><h1 class="c12" id="h.2fwkvofk8iin"><span class="c13 c6">Future Direction</span></h1><p class="c3"><span class="c2 c6">In future testing and comparing different piezoresistive fabrics to be used in applications such as: Gesture Recognition to help the impaired. </span></p><p class="c3"><span class="c2 c6">For further improvements to this project, the use of calibration algorithms and noise filtration circuits can help reduce the average percentage error in the circuits. &nbsp;</span></p><p class="c3"><span class="c2 c6">In addition to gesture recognition, pressure sensing technologies can help aid bionic/robot arms analyze pressure sensitivity and implement an algorithm regarding this.</span></p><p class="c3 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><h1 class="c12" id="h.xr3v4os4bxy5"><span class="c2 c0">Appendix A : Arduino four corner sensing code</span></h1><p class="c3 c4"><span class="c2 c0"></span></p><p class="c1"><span class="c5">#define side1 2</span></p><p class="c1"><span class="c5">#define side2 3</span></p><p class="c1"><span class="c5">#define side3 4</span></p><p class="c1"><span class="c5">#define side4 5</span></p><p class="c1"><span class="c5">#define contact A0</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">void setup() {</span></p><p class="c1"><span class="c5">&nbsp; pinMode(contact, INPUT); </span></p><p class="c1"><span class="c5">&nbsp; pinMode(side1, OUTPUT); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; pinMode(side2, OUTPUT); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; pinMode(side3, OUTPUT); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; pinMode(side4, OUTPUT); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; Serial.begin(9600);</span></p><p class="c1"><span class="c5">}</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">void loop() {</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp; // SENSOR VALUE 1:</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side1, LOW);</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side2, HIGH);</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side3, HIGH);</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side4, HIGH);</span></p><p class="c1"><span class="c5">&nbsp; delay(10);</span></p><p class="c1"><span class="c5">&nbsp; int sensorValue1 = analogRead(contact);</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp; // SENSOR VALUE 2:</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side2, LOW);</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side3, HIGH);</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side4, HIGH);</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side1, HIGH);</span></p><p class="c1"><span class="c5">&nbsp; delay(10);</span></p><p class="c1"><span class="c5">&nbsp; int sensorValue2 = analogRead(contact);</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp; // SENSOR VALUE 3:</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side3, LOW);</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side2, HIGH);</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side4, HIGH);</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side1, HIGH);</span></p><p class="c1"><span class="c5">&nbsp; delay(10);</span></p><p class="c1"><span class="c5">&nbsp; int sensorValue3 = analogRead(contact);</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp; // SENSOR VALUE 2:</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side4, LOW);</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side3, HIGH);</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side2, HIGH); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(side1, HIGH);</span></p><p class="c1"><span class="c5">&nbsp; delay(10);</span></p><p class="c1"><span class="c5">&nbsp; int sensorValue4 = analogRead(contact);</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp; Serial.print(sensorValue1);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(&quot;,&quot;);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(sensorValue2);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(&quot;,&quot;);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(sensorValue3);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(&quot;,&quot;);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(sensorValue4);</span></p><p class="c1"><span class="c5">&nbsp; Serial.println();</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp; </span></p><p class="c1"><span class="c5">&nbsp; int sidexone = 0;</span></p><p class="c1"><span class="c5">&nbsp; int sideyone = 0;</span></p><p class="c1"><span class="c5">&nbsp; int sidexthree = 0;</span></p><p class="c1"><span class="c5">&nbsp; int sideytwo= 0;</span></p><p class="c1"><span class="c5">&nbsp; int sidextwo = 1000;</span></p><p class="c1"><span class="c5">&nbsp; int sidexfour = 1000;</span></p><p class="c1"><span class="c5">&nbsp; int sideyfour = 1000;</span></p><p class="c1"><span class="c5">&nbsp; int sideythree= 1000;</span></p><p class="c1"><span class="c5">&nbsp; </span></p><p class="c1"><span class="c5">&nbsp; int a &nbsp;= (-1*(2)*sidexone)+(2*sidextwo);</span></p><p class="c1"><span class="c5">&nbsp; int b = ((-1*2*sideyone)+2*sideytwo);</span></p><p class="c1"><span class="c5">&nbsp; int c = (sensorValue1 * sensorValue1)- (sensorValue2 * sensorValue2)-(sidexone*sidexone)+(sidextwo*sidextwo)-(sideyone*sideyone)+(sideytwo*sideytwo);</span></p><p class="c1"><span class="c5">&nbsp; int d &nbsp;= (-1*2*sidextwo)+(2*sidexthree);</span></p><p class="c1"><span class="c5">&nbsp; int e = ((-1*2*sideytwo)+2*sideythree);</span></p><p class="c1"><span class="c5">&nbsp; int f = (sensorValue2 * sensorValue2)- (sensorValue3 * sensorValue3)-(sidextwo*sidextwo)+(sidexthree*sidexthree)-(sideytwo*sideytwo)+(sideythree*sideythree);</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp; int g &nbsp;= (&minus;2*x2+2*x4);</span></p><p class="c1"><span class="c5">&nbsp; int h = (&minus;2*sideytwo+2*y4);</span></p><p class="c1"><span class="c5">&nbsp; int i = (sensorValue2 * sensorValue2)- (sensorValue4 * sensorValue4)-(x2*x2)+(x4*x4)-(y4*y4)+(y4*y4); </span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp; int x = ((c*d)-(f*a))/((b*d)-(e*a));</span></p><p class="c1"><span class="c5">&nbsp; int y = ((a*e)-(d*b))/((c*e)-(f*b));</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp; Serial.print(a);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(&quot;a + &quot;);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(b);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(&quot;b + &quot;);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(c);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(&quot;c + &quot;);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(d);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(&quot;d + &quot;);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(e);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(&quot;e + &quot;);</span></p><p class="c3"><span class="c5">&nbsp; Serial.print(f);</span></p><p class="c3"><span class="c5">&nbsp; Serial.println(&quot;f&quot;);</span></p><p class="c3"><span class="c5">}</span></p><h1 class="c12" id="h.fqsf4njyitfu"><span class="c0 c19">Appendix B : Arduino X, Y coordinate determination program</span></h1><p class="c1"><span class="c5">#define sideX 2 &nbsp;</span></p><p class="c1"><span class="c5">#define sideX1 3 &nbsp;</span></p><p class="c1"><span class="c5">#define sideY 4 &nbsp;</span></p><p class="c1"><span class="c5">#define sideY1 5 &nbsp;</span></p><p class="c1"><span class="c5">#define contact A0</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">void setup() {</span></p><p class="c1"><span class="c5">&nbsp; pinMode(contact, INPUT); </span></p><p class="c1"><span class="c5">&nbsp; Serial.begin(9600);</span></p><p class="c1"><span class="c5">}</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">void loop() {</span></p><p class="c1"><span class="c5">&nbsp; // READ X-direction:</span></p><p class="c1"><span class="c5">&nbsp; pinMode(sideX, OUTPUT); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(sideX, LOW);</span></p><p class="c1"><span class="c5">&nbsp; pinMode(sideY, OUTPUT); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(sideY, HIGH);</span></p><p class="c1"><span class="c5">&nbsp; pinMode(sideX1, INPUT); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; pinMode(sideY1, INPUT); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; delay(10);</span></p><p class="c1"><span class="c5">&nbsp; int sensorValueX = analogRead(contact);</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp; // READ Y-direction:</span></p><p class="c1"><span class="c5">&nbsp; pinMode(sideY1, OUTPUT); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(sideY1, LOW);</span></p><p class="c1"><span class="c5">&nbsp; pinMode(sideX1, OUTPUT); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; digitalWrite(sideX1, HIGH);</span></p><p class="c1"><span class="c5">&nbsp; pinMode(sideX, INPUT); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; pinMode(sideY, INPUT); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; delay(10);</span></p><p class="c1"><span class="c5">&nbsp; int sensorValueY = analogRead(contact);</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp; Serial.print(sensorValueX);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(&quot;,&quot;);</span></p><p class="c1"><span class="c5">&nbsp; Serial.print(sensorValueY);</span></p><p class="c1"><span class="c5">&nbsp; Serial.println();</span></p><p class="c1"><span class="c5">}</span></p><p class="c3 c4"><span class="c2 c0"></span></p><h1 class="c12" id="h.xci3z3ikphjx"><span class="c2 c0">Appendix C : Processing circular intersection visualization </span></h1><p class="c1"><span class="c5">import processing.serial.*;</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">Serial myPort; &nbsp;// The serial port</span></p><p class="c1"><span class="c5">int maxNumberOfSensors = 2; &nbsp; &nbsp; </span></p><p class="c1"><span class="c5">float sensorValueX;</span></p><p class="c1"><span class="c5">float sensorValueY;</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">void setup () { </span></p><p class="c1"><span class="c5">&nbsp; size(600, 600); &nbsp;// set up the window to whatever size you want</span></p><p class="c1"><span class="c5">&nbsp; println(Serial.list()); &nbsp;// List all the available serial ports</span></p><p class="c1"><span class="c5">&nbsp; String portName = &quot;COM7&quot;;</span></p><p class="c1"><span class="c5">&nbsp; myPort = new Serial(this, portName, 9600);</span></p><p class="c1"><span class="c5">&nbsp; myPort.clear();</span></p><p class="c1"><span class="c5">&nbsp; myPort.bufferUntil(&#39;\n&#39;); &nbsp;// don&#39;t generate a serialEvent() until you get a newline (\n) byte</span></p><p class="c1"><span class="c5">&nbsp; background(255); &nbsp; &nbsp;// set inital background</span></p><p class="c1"><span class="c5">&nbsp; smooth(); &nbsp;// turn on antialiasing</span></p><p class="c1"><span class="c5">}</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">void draw () {</span></p><p class="c1"><span class="c5">&nbsp; background(255);</span></p><p class="c1"><span class="c5">&nbsp; strokeWeight(5);</span></p><p class="c1"><span class="c5">&nbsp; noFill();</span></p><p class="c1"><span class="c5">&nbsp; line(0, sensorValueX, height, sensorValueX);</span></p><p class="c1"><span class="c5">&nbsp; line(sensorValueY, 0, sensorValueY, width);</span></p><p class="c1"><span class="c5">&nbsp; ellipse(sensorValueY, sensorValueX, 20,20);</span></p><p class="c1"><span class="c5">}</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">void serialEvent (Serial myPort) {</span></p><p class="c1"><span class="c5">&nbsp; String inString = myPort.readStringUntil(&#39;\n&#39;); &nbsp;// get the ASCII string</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp; if (inString != null) { &nbsp;// if it&#39;s not empty</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; inString = trim(inString); &nbsp;// trim off any whitespace</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; int incomingValues[] = int(split(inString, &quot;,&quot;)); &nbsp;// convert to an array of ints</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp; &nbsp; if (incomingValues.length &lt;= maxNumberOfSensors &amp;&amp; incomingValues.length &gt; 0) {</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; incomingValues.length; i++) {</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; // map the incoming values (0 to &nbsp;1023) to an appropriate gray-scale range (0-255):</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; sensorValueX = map(incomingValues[0], 0, 1023, 0, width); </span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; sensorValueY = map(incomingValues[1], 0, 1023, 0, height);</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c5">&nbsp; }</span></p><p class="c1"><span class="c5">}</span></p><h1 class="c12" id="h.jvcp4wlz8hvj"><span class="c2 c0">Appendix D : Processing trilateration X,Y point visualization</span></h1><p class="c1"><span class="c5">import processing.serial.*;</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">import org.apache.commons.math3.linear.ArrayRealVector;</span></p><p class="c1"><span class="c5">import org.apache.commons.math3.linear.DiagonalMatrix;</span></p><p class="c1 c4"><span class="c5"></span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">Serial myPort; &nbsp;// The serial port</span></p><p class="c1"><span class="c5">int maxNumberOfSensors = 4; &nbsp;</span></p><p class="c1"><span class="c5">float[] sensorValues = new float[maxNumberOfSensors];</span></p><p class="c1"><span class="c5">float sensorValueX;</span></p><p class="c1"><span class="c5">float sensorValueX1;</span></p><p class="c1"><span class="c5">float sensorValueY;</span></p><p class="c1"><span class="c5">float sensorValueY1;</span></p><p class="c1"><span class="c5">int scaleValue = 2;</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">PVector trilateration(Sensor s1, Sensor s2, Sensor s3) {</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; PVector s = PVector.sub(s2.p, s1.p).div(PVector.sub(s2.p, s1.p).mag());</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; float a = s.dot(PVector.sub(s3.p, s1.p));</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; PVector t = PVector.sub(s3.p, s1.p).sub(PVector.mult(s, a)).div(PVector.sub(s3.p, s1.p).sub(PVector.mult(s, a)).mag());</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; float b = t.dot(PVector.sub(s3.p, s1.p));</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; float c = PVector.sub(s2.p, s1.p).mag();</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; </span></p><p class="c1"><span class="c5">&nbsp; &nbsp; </span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; float x = (sq(s1.d) - sq(s2.d) + sq(c)) / (c * 2);</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; float y = ((sq(s1.d) - sq(s3.d) + sq(a) + sq(b)) / (b * 2)) - ((a / b) * x);</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; s.mult(x);</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; t.mult(y);</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; return PVector.add(s1.p, s).add(t);</span></p><p class="c1"><span class="c5">}</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">void setup () {</span></p><p class="c1"><span class="c5">&nbsp; size(600, 600); &nbsp;// set up the window to whatever size you want</span></p><p class="c1"><span class="c5">&nbsp; //println(Serial.list()); &nbsp;// List all the available serial ports</span></p><p class="c1"><span class="c5">&nbsp; String portName = &quot;COM5&quot;;</span></p><p class="c1"><span class="c5">&nbsp; myPort = new Serial(this, portName, 9600);</span></p><p class="c1"><span class="c5">&nbsp; myPort.clear();</span></p><p class="c1"><span class="c5">&nbsp; myPort.bufferUntil(&#39;\n&#39;); &nbsp;// don&#39;t generate a serialEvent() until you get a newline (\n) byte</span></p><p class="c1"><span class="c5">&nbsp; background(255); &nbsp; &nbsp;// set inital background</span></p><p class="c1"><span class="c5">&nbsp; smooth(); &nbsp;// turn on antialiasing</span></p><p class="c1"><span class="c5">}</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">class Sensor {</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; public PVector p; // position</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; public float d; // distance from sensor to target (radius of the circle)</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; public Sensor(float x, float y, float d) {</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; this.p = new PVector(x, y);</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; this.d = d;</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c5">}</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">void draw () {</span></p><p class="c1"><span class="c5">&nbsp; background(255);</span></p><p class="c1"><span class="c5">&nbsp; noFill();</span></p><p class="c1"><span class="c5">&nbsp; fill(100,100,100,100);</span></p><p class="c1"><span class="c5">&nbsp; Sensor s1 = new Sensor(height,0, scaleValue*sensorValues[0]);</span></p><p class="c1"><span class="c5">&nbsp; Sensor s2 = new Sensor(0,width,scaleValue*sensorValues[1]);</span></p><p class="c1"><span class="c5">&nbsp; Sensor s3 = new Sensor(height, width, scaleValue*sensorValues[3]);</span></p><p class="c1"><span class="c5">&nbsp; Sensor s4 = new Sensor(0, 0, scaleValue*sensorValues[3]);</span></p><p class="c1"><span class="c5">&nbsp; </span></p><p class="c1"><span class="c5">&nbsp; ellipse(height,0, scaleValue*sensorValues[0], scaleValue*sensorValues[0]);</span></p><p class="c1"><span class="c5">&nbsp; ellipse(0,width, scaleValue*sensorValues[1], scaleValue*sensorValues[1]);</span></p><p class="c1"><span class="c5">&nbsp; ellipse(height,width, scaleValue*sensorValues[2], scaleValue*sensorValues[2]);</span></p><p class="c1"><span class="c5">&nbsp; ellipse(0,0, scaleValue*sensorValues[3], scaleValue*sensorValues[3]);</span></p><p class="c1"><span class="c5">&nbsp; </span></p><p class="c1"><span class="c5">&nbsp; ellipse(sensorValueY, sensorValueX, 10,10);</span></p><p class="c1"><span class="c5">&nbsp; println(sensorValueY,sensorValueX);</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">&nbsp; PVector target = trilateration(s1, s2, s3);</span></p><p class="c1"><span class="c5">&nbsp; ellipse(abs(target.x), abs(target.y), 10,10);</span></p><p class="c1"><span class="c5">&nbsp; println(target.x + &quot; &quot; + target.y);</span></p><p class="c1"><span class="c5">&nbsp; </span></p><p class="c1"><span class="c5">&nbsp; sensorValueX = ((sensorValues[2]*sensorValues[1])-(sensorValues[1]*sensorValues[1])+600*600)/2000;</span></p><p class="c1"><span class="c5">&nbsp; </span></p><p class="c1"><span class="c5">&nbsp; </span></p><p class="c1"><span class="c5">&nbsp; </span></p><p class="c1"><span class="c5">&nbsp; sensorValueX = ((sensorValues[3]*sensorValues[3])-(sensorValues[2]*sensorValues[2])+600*600)/2000;</span></p><p class="c1"><span class="c5">&nbsp; sensorValueX1 = ((sensorValues[0]*sensorValues[0])-(sensorValues[1]*sensorValues[1])+600*600)/2000;</span></p><p class="c1"><span class="c5">&nbsp; sensorValueY = ((sensorValues[3]*sensorValues[3])-(sensorValues[2]*sensorValues[2])+(600*600))/2000;</span></p><p class="c1"><span class="c5">&nbsp; sensorValueY1 = ((sensorValues[1]*sensorValues[1])-(sensorValues[0]*sensorValues[0])+(600*600))/2000;</span></p><p class="c1"><span class="c5">&nbsp; </span></p><p class="c1"><span class="c5">&nbsp; line(0, scaleValue*sensorValueX, height,scaleValue* sensorValueX);</span></p><p class="c1"><span class="c5">&nbsp; line(scaleValue*sensorValueY, 0, scaleValue*sensorValueY, width);</span></p><p class="c1"><span class="c5">&nbsp; ellipse(scaleValue*sensorValueY, scaleValue*sensorValueX, 20,20);</span></p><p class="c1"><span class="c5">&nbsp; line(0, scaleValue*sensorValueX1, height,scaleValue* sensorValueX1);</span></p><p class="c1"><span class="c5">&nbsp; line(scaleValue*sensorValueY1, 0, scaleValue*sensorValueY1, width);</span></p><p class="c1"><span class="c5">&nbsp; ellipse(scaleValue*sensorValueY1, scaleValue*sensorValueX1, 20,20);</span></p><p class="c1"><span class="c5">&nbsp; println(scaleValue*sensorValueX,scaleValue*sensorValueY);</span></p><p class="c1"><span class="c5">&nbsp; &nbsp;</span></p><p class="c1"><span class="c5">}</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">void serialEvent (Serial myPort) {</span></p><p class="c1"><span class="c5">&nbsp; String inString = myPort.readStringUntil(&#39;\n&#39;); &nbsp;// get the ASCII string</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">&nbsp; if (inString != null) { &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; inString = trim(inString); &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; int incomingValues[] = int(split(inString, &quot;,&quot;)); &nbsp;// convert to an array of ints</span></p><p class="c1"><span class="c5">&nbsp;</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; if (incomingValues.length &lt;= maxNumberOfSensors &amp;&amp; incomingValues.length &gt; 0) {</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; incomingValues.length; i++) {</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; // map the incoming values (0 to &nbsp;1023) to an appropriate gray-scale range (0-255):</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp;</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; sensorValues[i] = map(incomingValues[i], 0, 1023, 0, width);</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; //println(incomingValues[i]+ &quot; &quot; + sensorValues[i]);</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c5">&nbsp; &nbsp; }</span></p><p class="c1"><span class="c5">&nbsp; }</span></p><p class="c1 c4"><span class="c2 c6"></span></p><h1 class="c31" id="h.rah8j0ua6t29"><span class="c13 c6">References</span></h1><p class="c1 c4"><span class="c2 c6"></span></p><p class="c1 c20"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 340.00px;"><img alt="" src="images/image11.png" style="width: 624.00px; height: 340.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c11"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 228.00px;"><img alt="" src="images/image23.png" style="width: 624.00px; height: 228.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c11"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 121.33px;"><img alt="" src="images/image8.png" style="width: 624.00px; height: 121.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c4"><span class="c2 c6"></span></p><p class="c3 c4"><span class="c2 c0"></span></p><p class="c3 c11"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 120.00px;"><img alt="" src="images/image24.png" style="width: 624.00px; height: 120.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3 c11"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 137.33px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 137.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3 c11"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 233.33px;"><img alt="" src="images/image26.png" style="width: 624.00px; height: 233.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 204.00px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 204.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>